# 2つのベクトルを比較して、同じ位置にある要素ごとに対する処理を行いましょう♪

# ここでは、並列最大値と並列最小値を算出します。

n1 <- c(1, 12, 3, 14, 5)
n2 <- c(6, 7, 8, 9, 10)
print(pmax(n1, n2))
print(pmin(n1, n2))

# [1]  6 12  8 14 10
# [1] 1 7 3 9 5

# ベクトルの負の値を「0」にセットするには、pmax関数を使用します。

n2 <- c(-6, -7, 8, 9, -10)
print(pmax(n2, 0))

# [1]  0  0  8  9  0

# 配列から指定した条件の要素を取り出すには、[条件式]を使用します。

n3 <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
print(n3[n3 %% 2 == 0])

# [1]  2  4  6  8 10

# データを扱う際には、欠損値についても考慮する必要があります。
# 欠損値は、NAと表現されます。
# NAは、is.na関数で判定できます。

n4 <- c(1, 2, 3, NA, 5, 6, 7, 8, 9, 10)
print(is.na(n4))

# [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE

# NAを含む要素を全て「0」に変換するには「is.na」を使用します。

n5 <- c(1, 2, 3, NA, 5, 6, 7, 8, NA, 10)
n5[is.na(n5)] <- 0
print(n5)

# [1]  1  2  3  0  5  6  7  8  0 10

# 配列の各要素に対する処理を関数で実行させる場合には、sapply関数を使用します。

n6 <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
print(sapply(n6, function(x) x * 2))

# [1]  2  4  6  8 10 12 14 16 18 20

# NA要素を全て「0」に置換する処理をsapply関数で実行させる場合には、
# 以下のように記述します。

n7 <- c(1, 2, 3, NA, 5, 6, 7, 8, NA, 10)
print(sapply(n7, function(x) ifelse(is.na(x), 0, x)))

# [1]  1  2  3  0  5  6  7  8  0 10

# ☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★
# ★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆
# ☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★
# ★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆
# ☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★

# 次に配列同士の演算を行います。
# 既に学習済みの「+」、「-」、「*」、「/」を使用することができます。

n8 <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
n9 <- c(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
print(n8 + n9)

# [1] 11 11 11 11 11 11 11 11 11 11

n10 <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
n11 <- c(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
print(n10 - n11)

# [1] -9 -7 -5 -3 -1  1  3  5  7  9

n12 <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
n13 <- c(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
print(n12 * n13)

# [1] 10 18 24 28 30 30 28 24 18 10

n14 <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
n15 <- c(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
print(n14 / n15)

# [1] 0.1000000 0.2222222 0.3750000 0.5714286 0.8333333 1.2000000 1.7500000

# 2つの配列の要素数が異なる場合には、エラーが発生します。

n16 <- c(1, 2, 3, 4, 5)
n17 <- c(10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
# print(n16 + n17) # エラー

# longer object length is not a multiple of shorter object length
